---
alwaysApply: true
---
# Credit Check Application - Project Rules

## Project Context
This is a credit bureau system for the Marshall Islands that allows banks and lenders to:
- Submit credit data (payments, balances, account status)
- Query consumer credit reports (with consent)
- Manage user access and permissions
- Handle consumer disputes

## Security Requirements (CRITICAL)
- NEVER log sensitive data (SSN, account numbers, passwords) in plain text
- Always use parameterized queries to prevent SQL injection
- Encrypt sensitive data at rest (AES-256) and in transit (TLS 1.3)
- Implement rate limiting on all API endpoints
- Validate and sanitize ALL user inputs
- Use secure password hashing (bcrypt/Argon2, never MD5/SHA1)
- Implement CSRF protection on all state-changing operations
- Store API keys and secrets in environment variables, never in code
- Use JWT tokens with short expiration times
- Implement two-factor authentication for all admin and bank users

## Data Privacy & Compliance
- Always require explicit consumer consent before sharing credit data
- Log all credit inquiries with timestamp, user, and purpose
- Implement audit trails for all data access and modifications
- Follow principle of least privilege for all access controls
- Allow consumers to view, dispute, and freeze their credit data
- Implement data retention policies (typically 7 years for credit data)
- Never share credit data between banks without explicit consent
- Mask sensitive data in logs and error messages

## API Design Standards
- Use RESTful API conventions (GET, POST, PUT, DELETE, PATCH)
- Return consistent JSON response format: { "success": bool, "data": {}, "error": {}, "meta": {} }
- Use appropriate HTTP status codes (200, 201, 400, 401, 403, 404, 500)
- Implement pagination for list endpoints (limit, offset, total)
- Use versioning in API paths (/api/v1/...)
- Include request/response validation schemas
- Document all endpoints with OpenAPI/Swagger
- Implement idempotency keys for critical operations

## Database Design
- Use PostgreSQL as primary database
- Normalize data appropriately (avoid over-normalization)
- Create indexes on frequently queried fields (consumer_id, bank_id, created_at)
- Use foreign keys with proper constraints
- Implement soft deletes for audit purposes
- Use database transactions for multi-step operations
- Create database migrations for all schema changes
- Never use raw SQL strings, always use ORM or parameterized queries

## Authentication & Authorization
- Implement Role-Based Access Control (RBAC): ADMIN, BANK_MANAGER, BANK_USER, DATA_PROVIDER, AUDITOR, CONSUMER
- Use OAuth 2.0 / JWT for API authentication
- Implement refresh token rotation
- Check permissions at both route and resource level
- Validate user belongs to correct bank before data access
- Implement session management with secure cookies
- Log all authentication attempts (success and failure)

## Code Quality Standards
- Write self-documenting code with clear variable and function names
- Add comments for complex business logic and security-critical sections
- Follow language-specific style guides (PEP 8 for Python, ESLint for JavaScript)
- Keep functions small and focused (single responsibility principle)
- Avoid deep nesting (max 3-4 levels)
- Use TypeScript for frontend, type hints for Python backend
- Write unit tests for business logic (aim for 80%+ coverage)
- Write integration tests for API endpoints
- Use dependency injection for better testability

## Error Handling
- Never expose internal errors to end users
- Log detailed errors server-side with stack traces
- Return user-friendly error messages
- Implement proper error boundaries in frontend
- Use try-catch blocks appropriately
- Validate data at API boundary (input validation)
- Handle edge cases and null values gracefully

## Performance
- Implement database query optimization (avoid N+1 queries)
- Use Redis for caching frequently accessed data
- Implement connection pooling for database
- Use pagination for large datasets
- Optimize API response times (target <200ms for simple queries)
- Implement database indexes on foreign keys and search fields
- Use async/await for I/O operations

## Testing Requirements
- Write unit tests for all business logic functions
- Write integration tests for API endpoints
- Test authentication and authorization flows
- Test error handling and edge cases
- Test data validation and sanitization
- Use test fixtures for consistent test data
- Mock external services in tests
- Run tests in CI/CD pipeline before deployment

## Documentation
- Document all API endpoints with request/response examples
- Document database schema with relationships
- Document authentication and authorization flows
- Create README with setup instructions
- Document environment variables needed
- Create architecture diagrams for system design
- Document business rules and credit scoring logic

## Technology Stack Preferences
- Backend: Python (FastAPI/Django) or Node.js (Express/NestJS)
- Frontend: React with TypeScript
- Database: PostgreSQL
- Cache: Redis
- Authentication: JWT with OAuth 2.0
- Testing: pytest (Python) or Jest (Node.js)
- API Documentation: OpenAPI/Swagger

## Code Review Checklist
Before submitting code, ensure:
- [ ] Security best practices followed
- [ ] Input validation implemented
- [ ] Error handling in place
- [ ] Tests written and passing
- [ ] No sensitive data in logs
- [ ] Database queries are optimized
- [ ] API responses follow standard format
- [ ] Documentation updated if needed
- [ ] No hardcoded credentials or secrets
- [ ] Proper authentication/authorization checks

## Git & Version Control
- Use meaningful commit messages
- Create feature branches for new functionality
- Never commit secrets, API keys, or credentials
- Use .gitignore for environment files, node_modules, etc.
- Tag releases with semantic versioning (v1.0.0)
- Review code before merging to main branch